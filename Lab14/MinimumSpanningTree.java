package Lab14b;import Lab08.QueueInterface;import java.util.*;import java.util.concurrent.LinkedBlockingQueue;/** * A class that creates a minimum spanning tree * for a given graph * The graph is represented by adjacency matrix * * @author Kirsty Alexandra Nguegang * @author Anna Bieszczad * @version 5/1/2018 */public class MinimumSpanningTree{    // The matrix below represents the graph from the example provided in the lab description    // The instructor used this hardcoded matrix for testing,     //your code however must generate the matrix randomly//    private int[][] adjMatrix = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},//            {0, 0, 0, 3, 1, 0, 0, 0, 0, 0, 2},//            {0, 0, 0, 4, 0, 0, 10, 0, 0, 0, 0},//            {0, 3, 4, 0, 3, 5, 0, 0, 0, 0, 0},//            {0, 1, 0, 3, 0, 2, 0, 0, 0, 0, 0},//            {0, 0, 0, 5, 2, 0, 6, 0, 1, 0, 0},//            {0, 0, 10, 0, 0, 6, 0, 9, 10, 0, 0},//            {0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0},//            {0, 0, 0, 0, 0, 1, 10, 0, 0, 8, 0},//            {0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 10},//            {0, 2, 0, 0, 0, 0, 0, 0, 0, 10, 0}};    private int[][] adjMatrix;    private int[][] minimumSpanningTree;    private int numberOfNodes;    final int GRAYED_OUT = -1;    final int MARKED_FOR_CHECKING = -1;    final int PERCENT100 = 100;    public MinimumSpanningTree(int numberOfNodes, int probability)    {        //TODO Lab14b #1.1        //first, let's populate the matrix        Random random = new Random();        this.numberOfNodes = numberOfNodes;        this.adjMatrix = new int[numberOfNodes + 1][numberOfNodes + 1];        for (int row = 1; row < adjMatrix.length; row++)        {            for(int column = 2; column < adjMatrix.length; column++)            {                int mstProbability = random.nextInt(PERCENT100 + 1);                if (mstProbability < probability)                {                    if (row != column)                    {                        int weight = random.nextInt(numberOfNodes - 1 + 1) + 1;                        this.adjMatrix[row][column] = weight;                        this.adjMatrix[column][row] = weight;                    }                }            }        }    }    public boolean isConnected()    {        // TODO Lab14b #1.4 - this is wrong        // utilize BFS algorithm        int origin = 0;        boolean found = false;        for (int i = 1; i < this.adjMatrix.length && !found; i++) // to find the first non-zero element        {            for (int j = 2; j < this.adjMatrix.length && !found; j++)            {                if (this.adjMatrix[i][j] != 0)                {                    origin = this.adjMatrix[i][j];                    found = true;                }            }        }        boolean[] visited = new boolean[this.numberOfNodes + 1];        Queue<Integer> traversalOrder = new LinkedBlockingQueue<>();        Queue<Integer> nodeQueue = new LinkedBlockingQueue<>();        visited[origin] = true;        traversalOrder.offer(origin);        nodeQueue.offer(origin);        while (!nodeQueue.isEmpty())        {            int item = nodeQueue.poll();            for (int i = 1; i < this.adjMatrix.length; i++)            {                for (int j = 1; j < this.adjMatrix.length; j++)                {                    if (this.adjMatrix[i][j] != 0)                    {                        if (!visited[j])                        {                            visited[j] = true;                            traversalOrder.offer(j);                            nodeQueue.offer(j);                        }                    }                }            }        }        return traversalOrder.size() == this.numberOfNodes;    }    public boolean minimumSpanTreeCheckForCycle()    {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle(this.minimumSpanningTree, 1, visited);    }    public boolean connectedGraphCheckForCycle()    {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle(this.adjMatrix, 1, visited);    }    private boolean hasCycle(int[][] graphToCheck, int start, boolean[] visited)    {        // TODO Lab14b #1.5        //for (int j = start + 1; j <= this.numberOfNodes; j++) {        // if start and j are connected return true if either j was visited or recursive call starting with j returns true        //}        visited[start] = true;        for (int j = start + 1; j <= this.numberOfNodes; j++)        {            if ((graphToCheck[start][j] != 0 && graphToCheck[j][start] != 0))                 if (visited[j] || hasCycle(graphToCheck, j, visited))                    return true;        }        return false;    }    public void calculateMinimumSpanningTree()    {        // TODO Lab14b #1.3        // utilize findSmallestInMarkedRows method        this.minimumSpanningTree = new int[this.numberOfNodes + 1][this.numberOfNodes + 1];        this.adjMatrix[1][0] = MARKED_FOR_CHECKING; // marking first column        this.adjMatrix[0][1] = GRAYED_OUT;          // grayed out first column        int counter = this.numberOfNodes;        while (counter > 0)        {            Element item = findSmallestInMarkedRows();            this.minimumSpanningTree[item.row][item.column] = item.value;            this.minimumSpanningTree[item.column][item.row] = item.value;            this.adjMatrix[item.column][0] = MARKED_FOR_CHECKING;            this.adjMatrix[0][item.column] = GRAYED_OUT;            counter--;        }    }    private Element findSmallestInMarkedRows()    {        // TODO Lab14b #1.2        int smallest = this.numberOfNodes;        int row = 0;        int col = 0;        for (int i = 1; i < this.adjMatrix.length; i++)        {            if (this.adjMatrix[i][0] == MARKED_FOR_CHECKING)            {               for (int j = 2; j < this.adjMatrix.length; j++)               {                   if (this.adjMatrix[0][j] != GRAYED_OUT)                   {                       if (this.adjMatrix[i][j] > 0)                       {                           if (this.adjMatrix[i][j] < smallest)                           {                               smallest = this.adjMatrix[i][j];                               row = i;                               col = j;                           }                       }                   }               }            }        }        //System.out.println("row= " + row + "; col= " + col + "; smallest= " + smallest);        return new Element(row, col, smallest);    }    public void displayGraph()    {        System.out.println("***** GENERATED GRAPH *****");        displayMatrix(this.adjMatrix);    }    public void displayMinimumSpanningTree()    {        System.out.println("\n\n***** MINIMUM SPANNING TREE FOR THE ABOVE GRAPH *****");        displayMatrix(this.minimumSpanningTree);    }    private void displayMatrix(int[][] matrix)    {        System.out.print("     ");        for (int c = 1; c <= this.numberOfNodes; c++)        {            System.out.printf("[%1$2d]", c);        }        System.out.println();        for (int r = 1; r <= this.numberOfNodes; r++)        {            //System.out.print(r + " ");            System.out.printf("[%1$2d]", r);            for (int c = 1; c <= this.numberOfNodes; c++)            {                if (matrix[r][c] > 0)                    System.out.printf("%1$4d", matrix[r][c]);                else                    System.out.printf("%1$4s", " ");            }            System.out.println();        }    }    public static void main(String[] args)    {        System.out.println("How many nodes in your graph?");        Scanner scan = new Scanner(System.in);        int numberOfNodes = scan.nextInt();        System.out.println("Probability of edge? (type 70 for 70%)");        int probability = scan.nextInt();        MinimumSpanningTree graph = new MinimumSpanningTree(numberOfNodes, probability);        graph.displayGraph();        if (graph.isConnected())        {            if (graph.connectedGraphCheckForCycle())                System.out.println("\nThe graph has cycles.");            else                System.out.println("\nThe graph is acyclic.");            graph.calculateMinimumSpanningTree();            graph.displayMinimumSpanningTree();            if (graph.minimumSpanTreeCheckForCycle())                System.out.println("\nThe minimum spanning tree has cycles.");            else                System.out.println("\nThe minimum spanning tree is acyclic.");        }        else            System.out.println("The graph is not connected, the minimum spanning tree will not be calculated");    } // end main    private class Element    {        private int row;        private int column;        private int value;        public Element(int row, int column, int value)        {            this.row = row;            this.column = column;            this.value = value;        }    }}